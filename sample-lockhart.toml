[profiles.code]
api='Completion'
engine="text-davinci-003"
temperature=0
max_tokens=500
top_p=1.0
frequency_penalty=0.0
presence_penalty=0.0

[profiles.code-edit]
api='Edit'
engine="code-davinci-edit-001"
temperature=0
top_p=1.0

[prompts.docstring]
profile='code'
stop=["#", '"""']
prompt = '''
# Python 3.10

{{code}}

# Please write a high quality python docstring conforming to the google code style for docstrings for the above code.

The name of the function is: ```{{parsed.name}}```.

It has the following signature {{parsed.args}}.

Do not return the full function.
Only return the docstring.
Include an example if you can.
It should start with a short summary written in an imperative mood.
followed by a newline.
followed by a short description.
followed by another newline.
then followed by any of the following sections sections if they apply to this function (Args: , Returns: , Raises: , Yields: , Note: , Example: )
'''

[prompts.complete-func]
profile='code'
prompt = '''
# python3.10

fill in the following python function to do what the docstring says to do

{{ text }}
---
'''

[prompts.complete-func-long]
profile='code'
max_tokens=2000
prompt = '''
# python3.10

fill in the following python function to do what the docstring says to do

{{ text }}
---
'''

[prompts.generic]
engine="text-davinci-003"
api='Completion'
temperature=0
max_tokens=150
top_p=1.0
frequency_penalty=0.0
presence_penalty=0.0
stop=["#", '"""']
prompt = '''
{{ text }}
""""
'''

[prompts.generic-creative]
engine="text-davinci-003"
api='Completion'
temperature=0.8
max_tokens=150
top_p=1.0
frequency_penalty=0.0
presence_penalty=0.0
stop=["#", '"""']
prompt = '''
{{input('what do you want to do')}}

'''

[prompts.generic-long]
engine="text-davinci-003"
temperature=0
max_tokens=2000
top_p=1.0
frequency_penalty=0.0
presence_penalty=0.0
stop=["#", '"""']
prompt = '''
{{input('what do you want to do')}}
'''

[prompts.code-create]
profile='code-edit'
input='''
'''
instruction='''
create a python3.10 function to
'''

[prompts.code-edit]
profile='code-edit'
instruction='''
refactor the following python3.10 code to
'''
input='''
{{text}}
'''

[prompts.code-edit-example-1]
profile='code-edit'
instruction='''
create a python function to read text from a url
'''
input='''
'''

[prompts.create-history]
profile='code-edit'
instruction='''
write a python script to pickle a python list into a file called ~/.config/lockhart/history.pkl
'''
input='''
'''

[prompts.save-history]
profile='code-edit'
instruction='''
insert the current datetime into the object
'''
input='''
save_history(load_history().append({'request': prompt, 'response': response}))
'''

[prompts.create-history-pathlib]
profile='code-edit'
instruction='''
refactor this code to use pathlib instead of the os module
'''
input='''
#!/usr/bin/env python

import os
import pickle

from lockhart.console import console


def save_history(history):
    """
    Save the history to a file.
    """
    console.log(f"saving\n{history}")
    home = os.path.expanduser("~")
    config_dir = os.path.join(home, ".config", "lockhart")
    if not os.path.exists(config_dir):
        console.log(f"creating {config_dir}")
        os.makedirs(config_dir)
    history_file = os.path.join(config_dir, "history.pkl")
    with open(history_file, "wb") as f:
        pickle.dump(history, f)
    console.log(f"wrote history")


def load_history():
    """
    Load the history from a file.
    """
    home = os.path.expanduser("~")
    config_dir = os.path.join(home, ".config", "lockhart")
    history_file = os.path.join(config_dir, "history.pkl")
    if os.path.exists(history_file):
        with open(history_file, "rb") as f:
            history = pickle.load(f)
            console.log(f"loaded {len(history)} items into history")
            return history
    else:
        console.log(f"history_file does not exist, returning empty history")
        return []


if __name__ == "__main__":
    history = load_history()
    history.append("test")
    save_history(history)
'''

# write tests for this python module using the pytest framework
[prompts.create-history-testable]
profile='code-edit'
instruction='refactor this module so that it is more testable, the history file should be able to be overridden'
input='''
#!/usr/bin/env python

from pathlib import Path
import pickle

from lockhart.console import console


def save_history(history):
    """Save the history to a file."""
    console.log(f"saving\n{history}")
    config_dir = Path.home() / ".config" / "lockhart"
    config_dir.mkdir(parents=True, exist_ok=True)
    history_file = config_dir / "history.pkl"
    with history_file.open("wb") as f:
        pickle.dump(history, f)
    console.log(f"wrote history")


def load_history():
    """Load the history from a file."""
    config_dir = Path.home() / ".config" / "lockhart"
    history_file = config_dir / "history.pkl"
    if history_file.exists():
        with history_file.open("rb") as f:
            history = pickle.load(f)
            console.log(f"loaded {len(history)} items into history")
            return history
    else:
        console.log(f"history_file does not exist, returning empty history")
        return []


if __name__ == "__main__":
    history = load_history()
    history.append("test")
    save_history(history)
'''

[prompts.create-history-tests]
profile='code'
max_tokens=2000
prompt='''
Write tests for the following module using the pytest framework.  The tests should not affect the history file in my home directory.
#!/usr/bin/env python

from pathlib import Path
import pickle

from lockhart.console import console


def save_history(history, history_file=None):
    """Save the history to a file."""
    if history_file is None:
        history_file = get_history_file()
    console.log(f"saving\n{history} to {history_file}")
    with history_file.open("wb") as f:
        pickle.dump(history, f)
    console.log(f"wrote history")


def load_history(history_file=None):
    """Load the history from a file."""
    if history_file is None:
        history_file = get_history_file()
    if history_file.exists():
        with history_file.open("rb") as f:
            history = pickle.load(f)
            console.log(f"loaded {len(history)} items into history")
            return history
    else:
        console.log(f"history_file does not exist, returning empty history")
        return []


def get_history_file():
    config_dir = Path.home() / ".config" / "lockhart"
    config_dir.mkdir(parents=True, exist_ok=True)
    history_file = config_dir / "history.pkl"
    return history_file


if __name__ == "__main__":
    history = load_history()
    history.append("test")
    save_history(history)
'''

[prompts.refactor-history-tests]
profile='code-edit'
instruction='refactor this test module to use a temporary file instead of a path in my home directory'
input='''
import pytest
import os
import pickle

@pytest.fixture
def history_file():
    config_dir = Path.home() / ".config" / "lockhart"
    config_dir.mkdir(parents=True, exist_ok=True)
    history_file = config_dir / "history.pkl"
    return history_file

def test_save_history(history_file):
    history = ["test1", "test2"]
    save_history(history, history_file)
    assert os.path.exists(history_file)
    with open(history_file, "rb") as f:
        saved_history = pickle.load(f)
    assert saved_history == history

def test_load_history(history_file):
    history = ["test1", "test2"]
    with open(history_file, "wb") as f:
        pickle.dump(history, f)
    loaded_history = load_history(history_file)
    assert loaded_history == history

def test_load_history_empty(history_file):
    loaded_history = load_history(history_file)
    assert loaded_history == []
'''

[prompts.refactor-history-tests-pathlib]
profile='code-edit'
instruction='refactor this test so that the history_file passed into save_history and load_history are a pathlib.Path object'
input='''
import os
import pickle

import pytest

from lockhart.history import load_history, save_history


@pytest.fixture
def history_file(tmpdir):
    return tmpdir.join("history.pkl")


def test_save_history(history_file):
    history = ["test1", "test2"]
    save_history(history, history_file)
    assert os.path.exists(str(history_file))
    with open(str(history_file), "rb") as f:
        saved_history = pickle.load(f)
    assert saved_history == history


def test_load_history(history_file):
    history = ["test1", "test2"]
    with open(str(history_file), "wb") as f:
        pickle.dump(history, f)
    loaded_history = load_history(str(history_file))
    assert loaded_history == history


def test_load_history_empty(history_file):
    loaded_history = load_history(str(history_file))
    assert loaded_history == []
'''

[prompts.refactor-history-allow-strings]
profile='code-edit'
instruction='refactor the following code so that history_file can be a Pathlib.path object or a string representing a path'
input='''
#!/usr/bin/env python

from pathlib import Path
import pickle

from lockhart.console import console


def save_history(history, history_file=None):
    """Save the history to a file."""
    if history_file is None:
        history_file = get_history_file()
    console.log(f"saving\n{history} to {history_file}")
    with history_file.open("wb") as f:
        pickle.dump(history, f)
    console.log(f"wrote history")


def load_history(history_file=None):
    """Load the history from a file."""
    if history_file is None:
        history_file = get_history_file()
    if history_file.exists():
        with history_file.open("rb") as f:
            history = pickle.load(f)
            console.log(f"loaded {len(history)} items into history")
            return history
    else:
        console.log(f"history_file does not exist, returning empty history")
        return []


def get_history_file():
    config_dir = Path.home() / ".config" / "lockhart"
    config_dir.mkdir(parents=True, exist_ok=True)
    history_file = config_dir / "history.pkl"
    return history_file


if __name__ == "__main__":
    history = load_history()
    history.append("test")
    save_history(history)
'''
