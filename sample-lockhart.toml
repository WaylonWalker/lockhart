[profiles.code]
api='Completion'
engine="text-davinci-003"
temperature=0
max_tokens=500
top_p=1.0
frequency_penalty=0.0
presence_penalty=0.0

[profiles.code-edit]
api='Edit'
engine="code-davinci-edit-001"
temperature=0
top_p=1.0

[prompts.docstring]
profile='code'
stop=["#", '"""']
prompt = '''
# Python 3.10

{{code}}

# Please write a high quality python docstring conforming to the google code style for docstrings for the above code.

The name of the function is: ```{{parsed.name}}```.

It has the following signature {{parsed.args}}.

Do not return the full function.
Only return the docstring.
Include an example if you can.
It should start with a short summary written in an imperative mood.
followed by a newline.
followed by a short description.
followed by another newline.
then followed by any of the following sections sections if they apply to this function (Args: , Returns: , Raises: , Yields: , Note: , Example: )
'''

[prompts.complete-func]
profile='code'
prompt = '''
# python3.10

fill in the following python function to do what the docstring says to do

{{ text }}
---
'''

[prompts.complete-func-long]
profile='code'
max_tokens=2000
prompt = '''
# python3.10

fill in the following python function to do what the docstring says to do

{{ text }}
---
'''

[prompts.generic]
engine="text-davinci-003"
api='Completion'
temperature=0
max_tokens=150
top_p=1.0
frequency_penalty=0.0
presence_penalty=0.0
stop=["#", '"""']
prompt = '''
{{ text }}
""""
'''

[prompts.generic-creative]
engine="text-davinci-003"
api='Completion'
temperature=0.8
max_tokens=150
top_p=1.0
frequency_penalty=0.0
presence_penalty=0.0
stop=["#", '"""']
prompt = '''
{{input('what do you want to do')}}

'''

[prompts.generic-long]
engine="text-davinci-003"
temperature=0
max_tokens=2000
top_p=1.0
frequency_penalty=0.0
presence_penalty=0.0
stop=["#", '"""']
prompt = '''
{{input('what do you want to do')}}
'''

[prompts.code-create]
profile='code-edit'
input='''
'''
instruction='''
create a python3.10 function to
'''

[prompts.code-edit]
profile='code-edit'
instruction='''
refactor the following python3.10 code to
'''
input='''
{{text}}
'''

[prompts.code-edit-example-1]
profile='code-edit'
instruction='''
create a python function to read text from a url
'''
input='''
'''

[prompts.create-history]
profile='code-edit'
instruction='''
write a python script to pickle a python list into a file called ~/.config/lockhart/history.pkl
'''
input='''
'''

[prompts.save-history]
profile='code-edit'
instruction='''
insert the current datetime into the object
'''
input='''
save_history(load_history().append({'request': prompt, 'response': response}))
'''

[prompts.create-history-pathlib]
profile='code-edit'
instruction='''
refactor this code to use pathlib instead of the os module
'''
input='''
#!/usr/bin/env python

import os
import pickle

from lockhart.console import console


def save_history(history):
    """
    Save the history to a file.
    """
    console.log(f"saving\n{history}")
    home = os.path.expanduser("~")
    config_dir = os.path.join(home, ".config", "lockhart")
    if not os.path.exists(config_dir):
        console.log(f"creating {config_dir}")
        os.makedirs(config_dir)
    history_file = os.path.join(config_dir, "history.pkl")
    with open(history_file, "wb") as f:
        pickle.dump(history, f)
    console.log(f"wrote history")


def load_history():
    """
    Load the history from a file.
    """
    home = os.path.expanduser("~")
    config_dir = os.path.join(home, ".config", "lockhart")
    history_file = os.path.join(config_dir, "history.pkl")
    if os.path.exists(history_file):
        with open(history_file, "rb") as f:
            history = pickle.load(f)
            console.log(f"loaded {len(history)} items into history")
            return history
    else:
        console.log(f"history_file does not exist, returning empty history")
        return []


if __name__ == "__main__":
    history = load_history()
    history.append("test")
    save_history(history)
'''

# write tests for this python module using the pytest framework
[prompts.create-history-testable]
profile='code-edit'
instruction='refactor this module so that it is more testable, the history file should be able to be overridden'
input='''
#!/usr/bin/env python

from pathlib import Path
import pickle

from lockhart.console import console


def save_history(history):
    """Save the history to a file."""
    console.log(f"saving\n{history}")
    config_dir = Path.home() / ".config" / "lockhart"
    config_dir.mkdir(parents=True, exist_ok=True)
    history_file = config_dir / "history.pkl"
    with history_file.open("wb") as f:
        pickle.dump(history, f)
    console.log(f"wrote history")


def load_history():
    """Load the history from a file."""
    config_dir = Path.home() / ".config" / "lockhart"
    history_file = config_dir / "history.pkl"
    if history_file.exists():
        with history_file.open("rb") as f:
            history = pickle.load(f)
            console.log(f"loaded {len(history)} items into history")
            return history
    else:
        console.log(f"history_file does not exist, returning empty history")
        return []


if __name__ == "__main__":
    history = load_history()
    history.append("test")
    save_history(history)
'''

[prompts.create-history-tests]
profile='code'
max_tokens=2000
prompt='''
Write tests for the following module using the pytest framework.  The tests should not affect the history file in my home directory.
#!/usr/bin/env python

from pathlib import Path
import pickle

from lockhart.console import console


def save_history(history, history_file=None):
    """Save the history to a file."""
    if history_file is None:
        history_file = get_history_file()
    console.log(f"saving\n{history} to {history_file}")
    with history_file.open("wb") as f:
        pickle.dump(history, f)
    console.log(f"wrote history")


def load_history(history_file=None):
    """Load the history from a file."""
    if history_file is None:
        history_file = get_history_file()
    if history_file.exists():
        with history_file.open("rb") as f:
            history = pickle.load(f)
            console.log(f"loaded {len(history)} items into history")
            return history
    else:
        console.log(f"history_file does not exist, returning empty history")
        return []


def get_history_file():
    config_dir = Path.home() / ".config" / "lockhart"
    config_dir.mkdir(parents=True, exist_ok=True)
    history_file = config_dir / "history.pkl"
    return history_file


if __name__ == "__main__":
    history = load_history()
    history.append("test")
    save_history(history)
'''

[prompts.refactor-history-tests]
profile='code-edit'
instruction='refactor this test module to use a temporary file instead of a path in my home directory'
input='''
import pytest
import os
import pickle

@pytest.fixture
def history_file():
    config_dir = Path.home() / ".config" / "lockhart"
    config_dir.mkdir(parents=True, exist_ok=True)
    history_file = config_dir / "history.pkl"
    return history_file

def test_save_history(history_file):
    history = ["test1", "test2"]
    save_history(history, history_file)
    assert os.path.exists(history_file)
    with open(history_file, "rb") as f:
        saved_history = pickle.load(f)
    assert saved_history == history

def test_load_history(history_file):
    history = ["test1", "test2"]
    with open(history_file, "wb") as f:
        pickle.dump(history, f)
    loaded_history = load_history(history_file)
    assert loaded_history == history

def test_load_history_empty(history_file):
    loaded_history = load_history(history_file)
    assert loaded_history == []
'''

[prompts.refactor-history-tests-pathlib]
profile='code-edit'
instruction='refactor this test so that the history_file passed into save_history and load_history are a pathlib.Path object'
input='''
import os
import pickle

import pytest

from lockhart.history import load_history, save_history


@pytest.fixture
def history_file(tmpdir):
    return tmpdir.join("history.pkl")


def test_save_history(history_file):
    history = ["test1", "test2"]
    save_history(history, history_file)
    assert os.path.exists(str(history_file))
    with open(str(history_file), "rb") as f:
        saved_history = pickle.load(f)
    assert saved_history == history


def test_load_history(history_file):
    history = ["test1", "test2"]
    with open(str(history_file), "wb") as f:
        pickle.dump(history, f)
    loaded_history = load_history(str(history_file))
    assert loaded_history == history


def test_load_history_empty(history_file):
    loaded_history = load_history(str(history_file))
    assert loaded_history == []
'''

[prompts.refactor-history-allow-strings]
profile='code-edit'
instruction='refactor the following code so that history_file can be a Pathlib.path object or a string representing a path'
input='''
#!/usr/bin/env python

from pathlib import Path
import pickle

from lockhart.console import console


def save_history(history, history_file=None):
    """Save the history to a file."""
    if history_file is None:
        history_file = get_history_file()
    console.log(f"saving\n{history} to {history_file}")
    with history_file.open("wb") as f:
        pickle.dump(history, f)
    console.log(f"wrote history")


def load_history(history_file=None):
    """Load the history from a file."""
    if history_file is None:
        history_file = get_history_file()
    if history_file.exists():
        with history_file.open("rb") as f:
            history = pickle.load(f)
            console.log(f"loaded {len(history)} items into history")
            return history
    else:
        console.log(f"history_file does not exist, returning empty history")
        return []


def get_history_file():
    config_dir = Path.home() / ".config" / "lockhart"
    config_dir.mkdir(parents=True, exist_ok=True)
    history_file = config_dir / "history.pkl"
    return history_file


if __name__ == "__main__":
    history = load_history()
    history.append("test")
    save_history(history)
'''

[prompts.refactor-stdin]
profile='code-edit'
instruction='refactor the following code so that when nothing is piped into stdin it continues without blocking'
input='''
for line in sys.stdin:
    text = text + line
'''

[prompts.create-stdin-read]
profile='code-edit'
instruction='''
create a python function that returns any text piped into it from the shell
'''
input='''
'''

[prompts.create-plugin-system]
profile='code-edit'
instruction='''
create a python module to create a plugin system using pluggy where the user can give plugin modules as a string it will load and register them.
'''
input='''
'''

[prompts.create-plugin]
profile='code-edit'
instruction='''
create a python plugin using pluggy, the hookspec and hookimpl is located in lockhartplugin.py.  there is only one hookimpl and it is hello.
'''
input='''
'''

[prompts.edit-toml]
profile='code-edit'
instruction='''
edit the following pyhton3.10 code to write the full prompt to the temprary file as toml, change the tempfile extention to toml, and load all of the tempfile as the new prompt using the toml loader
'''
input='''
editor = os.environ.get("EDITOR", "vim")
console.log(f"editing prompt with {editor}")
file = tempfile.NamedTemporaryFile(prefix="lockhart")
file.write(prompt["prompt"].encode())
file.seek(0)
proc = subprocess.Popen([editor, file.name])
proc.wait()
if os.stat(file.name).st_mtime != os.stat(file.name).st_atime:
    console.log("editor quit")
    return

prompt["prompt"] = file.read().decode()
'''
